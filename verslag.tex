
\documentclass[10pt]{article}

\parindent=0pt

\usepackage{fullpage}

\frenchspacing

\usepackage{microtype}

\usepackage[english,dutch]{babel}

\usepackage{graphicx}

\usepackage{listings}

\lstset{language=C++, showstringspaces=false, basicstyle=\small,
  numbers=left, numberstyle=\tiny, numberfirstline=false, breaklines=true,
  stepnumber=1, tabsize=8, 
  commentstyle=\ttfamily, identifierstyle=\ttfamily,
  stringstyle=\itshape}

\usepackage[setpagesize=false,colorlinks=true,linkcolor=red,urlcolor=blue,pdftitle={Kunstmatige Intelligentie bij Tetris},pdfauthor={Alex Keizer}]{hyperref}

\author{Bram Honig \and Alex Keizer}
\title{Kunstmatige Intelligentie bij Tetris}

\begin{document}

\selectlanguage{dutch}

\maketitle

\section{Inleiding} 
Tetris staat voornamelijk bekend als een spelletje waar je een goed reactievermogen voor moet hebben. Toch zorgen de vele mogelijke manieren om een stuk te plaatsen het feit dat je niet weet welke stukken nog gaan komen ervoor dat het zeker niet recht toe recht aan duidelijk is wat de beste zet op een gegeven moment is. In onze zoektocht zullen wij ons slechts beperken tot het stuk wat we op een gegeven moment ktijgen en niet nog zetten vooruit gaan denken.

Waarschijnlijk kennen de meesten de regels van Tetris wel, maar voor de volledigheid zullen we ze nog noemen. Elke zet krijg je een stuk, waar de speler moet bepalen op welke plek en met welke rotatie we het laten vallen. Dit mag, in onze variatie, tijdens het vallen niet veranderd worden. Als een rij compleet vol zit zal deze worden weggehaald en de vakjes erboven zullen een rij naar beneden vallen. Het spel is voorbij wanneer een stuk niet meer op het bord past.

\section{Uitleg probleem}\label{probleem}

Elke ``beurt'' krijgen we een (willekeurig) stuk, onze zet bestaat dan vervolgens uit de kolom waar we dat stuk laten vallen en met welke rotatie we dat doen. In onze variatie hebben we dus geen kennis over welk stuk gaat volgen. Aangezien er aanzienlijk wat mogelijkheden zijn is het erg lastig om te bepalen wat de optimaalste zet is. Zelfs als een preciese reeks stukken gegeven wordt is het een NP-hard probleem om de beste zetten te vinden. \cite{nphard} (zie sectie \ref{relevant})

\section{Relevant werk}\label{relevant}

In eerder onderzoek is aangetoond dat het bepalen van de beste zetten voor het meerdere aspecten van tetris zoals tetrissen geplaats of de meeste rijen verwijderd een NP-clomplete probleem\cite{nphard} is. Dit houdt in dat als er een oplossing wordt aangeboden deze heel makkelijk te verifieren is echter om een oplossing te vinden is dit mogelijk binnen polynomiale tijd echter neemt dit toe naarmate de complexiteit van het probleem toeneemt. Om deze reden is tetris op het moment niet op te lossen op die manier binnen een re"{e}el tijdspan. Om deze reden is er ook onderzoek gedaan naar hoe goed algoritme tetris kan spelen op basis van parameters met een evualatie functie voor zetten. Bij het onderzoek uit 2015 \"An Evolutionary Approach to Tetris\" \cite{genetic} werden 12 parameters gebruikt waar de evualatie functie zich op baseerde waarvan we 4 hebben overgenomen: Aantal verwijderde rijen,aantal lege vakjes met een vakje in dezelfde kolom, hoogte verschil tussen kolommen en lege vakjes. Om de het gewicht van elke parameter te bepalen werd gebruik gemaakt van een genetisch algoritme. Een van de conclusies was dat er veel locale optima waren waar het algoritme niet kon ontsnappen om die reden hebben wij ons dus meer gefocussed op een optima vinden en daarmee verder onderzoek te doen. Verder zouden we niet kunnen concureren met op het punt van hoveelheid parameters en testen in verband met tijdsbeperkingen en rekenvermogen.

\section{Aanpak}

Als eerste poging is er een Monte-Carlo algoritme gemaakt. Bij elke beurt wordt elke mogelijke zet een vast aantal willekeurige potjes gespeeld. De zet waarbij in al die spelletjes het meeste stukken werden gespeeld wordt gekozen als de beste zet.

Willekeurig spelen is niet erg effici\"{e}nt, dus hebben we ook een ``slim'' algoritme. Zoals gezegd in sectie \ref{probleem} wordt een speelboom al snel erg groot, wij hebben ons dus beperkt tot alle mogelijkheden met het huidige stuk. Elk van deze mogelijkheden wordt ge\"{e}valueerd aan de hand van de volgende punten:
\begin{itemize}

\item De hoogste rij met bezette vakjes (in het kwadraat)

\item Lege vakjes in de hoogst bezette rij

\item Weggehaalde rijen

\item Lege vakjes met erboven (in dezelfde kolom) ene niet-leeg vakje

\item Het hoogteverschil tussen opeenvolgende rijen

\end{itemize}
Hoe hoger de stapel wilt, hoe erger het is als hij verder stijgt (je komt immers telkens dichter bij het einde). We hebben dus niet direct het nummer van de hoogste rij gepakt, maar het kwadraat daarvan als meetpunt. Elk van deze punten wordt vervolgens met een coeffic\"{i}ent vermenigvuldigt en bij elkaar opgeteld, dit is de uiteindelijke score voor dat bord (en de zet die tot dat bord heeft geleid). Verder wordt natuurlijk weer de zet met de hoogste score gedaan.

\section{Implementatie}

We hebben gewerkt met C++. Voor de slim en Monte-Carlo functie hebben we gebruikt gemaakt van de possibilities functie die in de geleverde code zat die het aantal mogelijke zetten berekenend hiervan geven we het stuk, orientatie en positie door aan een evualatie functie voor of Monte-Carlo of Slim. De evaluatie funcite werkt met de eerder genoemde 4 parameters : Toprow, aantal lege vakjes toprow, lege vakjes met een vakje erboven in dezelfde column. Die met zekere coefficienten een score op leveren. In deze slimme evualatie functie wordt een kopie gemaakt van het Tetris object en gekeken naar de score van het bord nadat de zet gedaan is. Bij de evaluatie functie van Monte-Carlo wordt er per zet 1000 keer op een kopie van het Tetris object een Random spel uitgespeeld doormiddel van de bijgeleverde PlayRandomGame functie waarbij de score wordt bepaald door het gemiddelde van de potjes.

De coefficienten hebben we expirimenteel bepaald.

\section{Experimenten}

Voor het berekenenen van de coefficienten hebben we alle coefficienten een waarde van tussen de -5 en 5 aan laten nemen en met die coefficienten in de evaluatie functie 100 potjes te laten spelen waarvan wij het gemiddelde als score zien.


De resultaten van de experimenten zijn te
vinden in onderstaande tabel:

\begin{center}
\begin{tabular}{l|l|l}
experiment & tijd (sec) & uitslag\\
\hline
1 & 10 & $-7$\\
2 & 42 & 123
\end{tabular}
\end{center}
Hoe verklaren we dit? En waar is de grafiek?

\section{Conclusie}

Leuk onderzoek, veelbelovend ook. Het ging helaas 
fout als de testopstelling niet verlicht was.
In de toekomst doen we dat anders.

\begin{thebibliography}{XX}

\bibitem{nphard}
Erik D. Demaine, Susan Hohenberger and David Liben-Nowell, Tetris is
Hard, Even to Approximate. In Proceedings of the 9th International Computing and
Combinatorics Conference (COCOON 2003) (2003).

\bibitem{genetic}
https://www2.informatik.uni-erlangen.de/EN/publication/download/mic.pdf

\end{thebibliography}

\section*{Appendix: Code}

Er is gebruik gemaakt van de \href{http://www.liacs.leidenuniv.nl/~kosterswa/AI/iets.cc}{\underline{skeletcode}} die te vinden is via
de website van het college.
De code van het programma is als volgt:

\smallskip


\end{document}
